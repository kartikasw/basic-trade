// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: variant.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const createVariant = `-- name: CreateVariant :one
INSERT INTO variants (
    variant_name,
    quantity,
    product_id
) VALUES (
    $1, $2, $3
)
RETURNING uuid, variant_name, quantity
`

type CreateVariantParams struct {
	VariantName string `json:"variant_name"`
	Quantity    int32  `json:"quantity"`
	ProductID   int64  `json:"product_id"`
}

type CreateVariantRow struct {
	Uuid        uuid.UUID `json:"uuid"`
	VariantName string    `json:"variant_name"`
	Quantity    int32     `json:"quantity"`
}

func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) (CreateVariantRow, error) {
	row := q.db.QueryRow(ctx, createVariant, arg.VariantName, arg.Quantity, arg.ProductID)
	var i CreateVariantRow
	err := row.Scan(&i.Uuid, &i.VariantName, &i.Quantity)
	return i, err
}

const deleteVariant = `-- name: DeleteVariant :exec
DELETE FROM variants WHERE uuid = $1
`

func (q *Queries) DeleteVariant(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVariant, argUuid)
	return err
}

const getVariant = `-- name: GetVariant :one
SELECT uuid, variant_name, quantity, product_id FROM variants
WHERE uuid = $1 LIMIT 1
`

type GetVariantRow struct {
	Uuid        uuid.UUID `json:"uuid"`
	VariantName string    `json:"variant_name"`
	Quantity    int32     `json:"quantity"`
	ProductID   int64     `json:"product_id"`
}

func (q *Queries) GetVariant(ctx context.Context, argUuid uuid.UUID) (GetVariantRow, error) {
	row := q.db.QueryRow(ctx, getVariant, argUuid)
	var i GetVariantRow
	err := row.Scan(
		&i.Uuid,
		&i.VariantName,
		&i.Quantity,
		&i.ProductID,
	)
	return i, err
}

const getVariantForUpdate = `-- name: GetVariantForUpdate :one
SELECT uuid, variant_name, quantity FROM variants
WHERE uuid = $1 LIMIT 1
FOR NO KEY UPDATE
`

type GetVariantForUpdateRow struct {
	Uuid        uuid.UUID `json:"uuid"`
	VariantName string    `json:"variant_name"`
	Quantity    int32     `json:"quantity"`
}

func (q *Queries) GetVariantForUpdate(ctx context.Context, argUuid uuid.UUID) (GetVariantForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getVariantForUpdate, argUuid)
	var i GetVariantForUpdateRow
	err := row.Scan(&i.Uuid, &i.VariantName, &i.Quantity)
	return i, err
}

const getVariantsCount = `-- name: GetVariantsCount :one
WITH total_count AS (
    SELECT COUNT(*) AS total_count
    FROM variants
)
SELECT total_count FROM total_count
`

func (q *Queries) GetVariantsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getVariantsCount)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const listVariants = `-- name: ListVariants :many
SELECT 
    ROW_NUMBER() OVER (ORDER BY created_at DESC),
    uuid, 
    variant_name, 
    quantity
FROM variants
WHERE $1::text = ':*' OR ($1::text != ':*' AND variant_name_search @@ to_tsquery('simple', $1::text))
ORDER BY created_at DESC
LIMIT $3::integer
OFFSET $2::integer * $3::integer
`

type ListVariantsParams struct {
	Keyword   string `json:"keyword"`
	OffsetVal int32  `json:"offset_val"`
	LimitVal  int32  `json:"limit_val"`
}

type ListVariantsRow struct {
	RowNumber   int64     `json:"row_number"`
	Uuid        uuid.UUID `json:"uuid"`
	VariantName string    `json:"variant_name"`
	Quantity    int32     `json:"quantity"`
}

func (q *Queries) ListVariants(ctx context.Context, arg ListVariantsParams) ([]ListVariantsRow, error) {
	rows, err := q.db.Query(ctx, listVariants, arg.Keyword, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVariantsRow{}
	for rows.Next() {
		var i ListVariantsRow
		if err := rows.Scan(
			&i.RowNumber,
			&i.Uuid,
			&i.VariantName,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAVariant = `-- name: UpdateAVariant :one
UPDATE variants SET 
    variant_name = CASE WHEN $3::bool
    THEN $4::text
    ELSE variant_name
    END,
    quantity = $2
WHERE uuid = $1
RETURNING uuid, variant_name, quantity, product_id
`

type UpdateAVariantParams struct {
	Uuid           uuid.UUID `json:"uuid"`
	Quantity       int32     `json:"quantity"`
	SetVariantName bool      `json:"set_variant_name"`
	VariantName    string    `json:"variant_name"`
}

type UpdateAVariantRow struct {
	Uuid        uuid.UUID `json:"uuid"`
	VariantName string    `json:"variant_name"`
	Quantity    int32     `json:"quantity"`
	ProductID   int64     `json:"product_id"`
}

func (q *Queries) UpdateAVariant(ctx context.Context, arg UpdateAVariantParams) (UpdateAVariantRow, error) {
	row := q.db.QueryRow(ctx, updateAVariant,
		arg.Uuid,
		arg.Quantity,
		arg.SetVariantName,
		arg.VariantName,
	)
	var i UpdateAVariantRow
	err := row.Scan(
		&i.Uuid,
		&i.VariantName,
		&i.Quantity,
		&i.ProductID,
	)
	return i, err
}
